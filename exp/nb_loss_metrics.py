
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/loss_metrics.ipynb

#================================================
import torch


#================================================
from torch.nn import functional as F


#================================================
from torch import tensor


#================================================
import numpy as np


#================================================
def dice_coef(input, target):
    smooth = 1.

    pred = input.sigmoid()
    target = target.float()

    return ((2. * (pred * target).sum() + smooth) / (pred.sum() + target.sum() +smooth))


#================================================
def dice_loss(input, target):
    return 1 - dice_coef(input, target)


#================================================
def weighted_bce(input, target, pos_weight=0):
    """
    pos_weight: positive weight relative to negative weight(which is 1)
    """
    if pos_weight>0:
        mask = target.float()
        weight = (mask*pos_weight + (1-mask))
        weight = weight/weight.sum()*mask.numel()
        return F.binary_cross_entropy_with_logits(input, target, weight=weight)
    else:
        return F.binary_cross_entropy_with_logits(input, target)


#================================================
def balance_bce(input, target, balance_ratio=0):
    """
    Auto adjust positive/negative ration as set by balance_ratio.
    """
    if balance_ratio>0:
        mask = target.float()
        posN = mask.sum().clamp(1)
        negN = (1-mask).sum().clamp(1)
        pos_weight = balance_ratio*negN/posN
        return weighted_bce(input, target, pos_weight)
    else:
        return weighted_bce(input, target)


#================================================
def combo_loss(input,target,balance_ratio=0):
    return dice_loss(input,target)+balance_bce(input,target,balance_ratio)


#================================================
def mask_iou(input, target):
    """
    iou for segmentation
    """
    pred_mask = input>0
    target_mask = target>0

    i = (pred_mask&target_mask).float().sum()
    u = (pred_mask|target_mask).float().sum()
    return i/u
